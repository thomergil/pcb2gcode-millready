#!/usr/bin/env python3
"""
pcb2gcode-millready

This tool modifies G-code files generated by pcb2gcode (https://github.com/pcb2gcode/pcb2gcode)
to make them more suitable for CNC milling operations. It performs two main functions:

1. Removes initial tool change sequences which require manual intervention
2. Swaps Z and X/Y moves to ensure the tool moves to position first before plunging

By default, both operations are performed. Command-line flags allow disabling either operation.

Note: This code was mostly generated with the assistance of AI (Claude).
"""

import re
import argparse
import os
import sys

# Constants
# Maximum number of lines to check forward when searching for patterns
MAX_TOOL_CHANGE_LOOK_AHEAD = 10  # Lines to check for tool change sequence
MAX_SPINDLE_START_LOOK_AHEAD = 5  # Lines to check for M3 after M0
MAX_SPINDLE_WAIT_LOOK_AHEAD = 5  # Lines to check for spindle wait after M3

# XY/Z swap pattern constants
MIN_PATTERN_LINES = 4  # Minimum lines needed for Z/XY swap pattern


def remove_tool_change_sequence(infile, outfile):
    """
    Remove the initial tool change sequence from G-code.
    
    This function identifies and removes the initial tool change sequence in
    the G-code that would normally require manual intervention. It preserves
    the spindle commands (M3) and wait times to ensure proper spindle
    operation. Only the first (initial) tool change sequence is removed.
    
    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file
    
    Returns:
        bool: True if the initial tool change sequence was found and removed, False otherwise
    """
    # Read the input file
    with open(infile, 'r') as f:
        lines = f.readlines()
    
    # Find the initial tool change sequence
    tool_change_start = -1
    tool_change_end = -1
    spindle_wait_line = None  # Store the spindle wait line
    
    # Look for the pattern: retract → T command → M5 → wait → message → M0 → M3 → wait
    for i in range(len(lines) - 1):
        # Look for a retract to tool change height
        if re.search(r'G0[0]?\s+Z.*retract|tool.*change', lines[i], re.IGNORECASE):
            # Check if there's a tool command, M5, and M0 in the following lines
            has_tool_cmd = False
            has_spindle_stop = False
            has_message = False
            has_machine_stop = False
            m3_index = -1
            
            # Look at the next few lines to see if they match the pattern
            for j in range(i, min(i+MAX_TOOL_CHANGE_LOOK_AHEAD, len(lines))):
                if re.match(r'^\s*T', lines[j].strip()):
                    has_tool_cmd = True
                if 'M5' in lines[j]:
                    has_spindle_stop = True
                if '(MSG' in lines[j] or 'message' in lines[j].lower():
                    has_message = True
                if 'M0' in lines[j]:
                    has_machine_stop = True
                    # Find where to end the tool change sequence (at M3 line)
                    for k in range(j+1, min(j+MAX_SPINDLE_START_LOOK_AHEAD, len(lines))):
                        if 'M3' in lines[k]:
                            m3_index = k
                            # Find the spindle wait line after M3
                            for m in range(k+1, min(k+MAX_SPINDLE_WAIT_LOOK_AHEAD, len(lines))):
                                if re.search(r'G04\s+P.*speed', lines[m], re.IGNORECASE):
                                    spindle_wait_line = lines[m]
                                    tool_change_start = i
                                    tool_change_end = k  # End at M3 line, not including wait
                                    break
                            break
                    break
            
            # If we found a complete sequence, break immediately to only remove the initial one
            if has_tool_cmd and has_spindle_stop and has_message and has_machine_stop and tool_change_end > 0:
                break
    
    # If we found the initial tool change sequence, remove it
    if tool_change_start >= 0 and tool_change_end >= tool_change_start:
        # Create new content without the tool change sequence but preserving the necessary M3 command
        # Find the M3 line to extract the spindle settings
        spindle_cmd = "M3"
        for i in range(tool_change_start, tool_change_end + 1):
            if "M3" in lines[i]:
                spindle_cmd = lines[i].strip()
                break
        
        new_lines = lines[:tool_change_start]
        new_lines.append(f'{spindle_cmd}\n')
        
        # Add the spindle wait line if found
        if spindle_wait_line:
            new_lines.append(spindle_wait_line)
        
        # Add remaining lines after tool change sequence and wait
        next_line_index = tool_change_end + 1
        if spindle_wait_line:
            # Skip the wait line when adding remaining lines to avoid duplication
            for i in range(tool_change_end + 1, len(lines)):
                if lines[i] == spindle_wait_line:
                    next_line_index = i + 1
                    break
        
        new_lines.extend(lines[next_line_index:])
        
        # Write the modified content to the output file
        with open(outfile, 'w') as f:
            f.writelines(new_lines)
        
        print(f"Initial tool change sequence removed. Modified G-code saved to {outfile}")
        return True
    else:
        print("No initial tool change sequence found in the file.")
        # Just copy the file if no sequence found
        with open(outfile, 'w') as f:
            f.writelines(lines)
        return False


def swap_z_and_xy_moves(infile, outfile):
    """
    Swap Z-down moves followed by X,Y moves to be X,Y moves followed by Z-down.
    
    This modification ensures the tool moves to the starting position first, then plunges down.
    Only the first occurrence is swapped, which typically is the start of the actual milling operation.
    This function also adds a move to machine Z0 (using G53) before the X,Y move to ensure tool clearance.
    
    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file
    
    Returns:
        bool: True if the swap was performed, False otherwise
    """
    # Read the input file
    with open(infile, 'r') as f:
        lines = f.readlines()
    
    new_lines = []
    i = 0
    swapped = False  # Flag to track if we've already done the swap
    
    while i < len(lines):
        # Look for Z-down move followed by X,Y move, but only swap the first occurrence
        if (not swapped and i+MIN_PATTERN_LINES-1 < len(lines) and 
            re.search(r'G0[0-9]?\s+Z-', lines[i]) and  # Z-down move
            'G04 P0' in lines[i+1] and  # Dwell
            ('F' in lines[i+2] or 'F100' in lines[i+2]) and  # Feed rate
            re.search(r'G0[0-9]?\s+X.*Y', lines[i+3])):  # X,Y move
            
            # Keep the z-move and dwell lines but save them for later
            z_move = lines[i]
            dwell_line = lines[i+1]
            feed_line = lines[i+2]
            xy_move = lines[i+3]
            
            # Add the lines in the new order: Machine Z0 move first, then X,Y move, then Z down move
            new_lines.append("G53 G0 Z0\n")  # Move to machine Z0 first for clearance
            new_lines.append(xy_move)  # X,Y move
            new_lines.append(z_move)   # Z move
            new_lines.append(dwell_line)  # Dwell
            new_lines.append(feed_line)   # Feed rate
            
            i += MIN_PATTERN_LINES  # Skip these 4 lines since we've handled them
            swapped = True  # Mark that we've done the swap
            
            print(f"Added machine Z0 move (G53) and swapped first occurrence of Z and X,Y moves")
        else:
            # Keep the line as is
            new_lines.append(lines[i])
            i += 1
    
    # Write the modified content to the output file
    with open(outfile, 'w') as f:
        f.writelines(new_lines)
    
    if swapped:
        print(f"Machine Z0 move (G53) added and Z/X,Y moves swapped (first occurrence only). Modified G-code saved to {outfile}")
    else:
        print(f"No Z and X,Y move pattern found to swap. G-code copied to {outfile}")
    
    return swapped


def main():
    """
    Main function to process command line arguments and execute G-code modifications.
    """
    parser = argparse.ArgumentParser(
        description="""
        PCB2GCode G-code Post-Processor
        
        Modifies G-code files generated by pcb2gcode (https://github.com/pcb2gcode/pcb2gcode)
        to make them more suitable for CNC milling operations. By default, it removes tool 
        change sequences and swaps Z/XY moves for safer operation.
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('infile', help='Input G-code file generated by pcb2gcode')
    parser.add_argument('outfile', help='Output G-code file')
    parser.add_argument('--no-swap', action='store_true', 
                        help='Skip swapping Z and X,Y moves (default: perform swap)')
    parser.add_argument('--no-remove-tool-change', action='store_true',
                        help='Skip removing tool change sequences (default: remove sequences)')
    parser.add_argument('--version', action='version', version='%(prog)s 1.0.0')
    
    args = parser.parse_args()
    
    # Check if input file exists
    if not os.path.exists(args.infile):
        print(f"Error: Input file '{args.infile}' not found.", file=sys.stderr)
        sys.exit(1)
    
    # Check if output directory exists
    outdir = os.path.dirname(args.outfile)
    if outdir and not os.path.exists(outdir):
        print(f"Creating output directory: {outdir}")
        os.makedirs(outdir, exist_ok=True)
    
    # Set up intermediate file
    temp_file = args.outfile + ".temp"
    current_input = args.infile
    
    # Process the file according to flags
    try:
        # Step 1: Remove tool change sequence if not disabled
        if not args.no_remove_tool_change:
            print("Processing: Removing tool change sequences...")
            remove_tool_change_sequence(current_input, temp_file)
            current_input = temp_file
        
        # Step 2: Swap Z and X,Y moves if not disabled
        if not args.no_swap:
            print("Processing: Swapping Z and X,Y moves...")
            swap_z_and_xy_moves(current_input, args.outfile)
        elif current_input == temp_file:
            # If we used a temp file but won't be doing the swap, just rename it
            os.rename(temp_file, args.outfile)
        else:
            # If we're not doing any processing, just copy the input file
            with open(args.infile, 'r') as src, open(args.outfile, 'w') as dst:
                dst.writelines(src.readlines())
            print(f"No processing requested. Input file copied to {args.outfile}")
        
        # Clean up temp file if it exists
        if os.path.exists(temp_file):
            os.remove(temp_file)
        
        print(f"Processing complete. Final G-code saved to {args.outfile}")
        
    except Exception as e:
        print(f"Error processing G-code: {e}", file=sys.stderr)
        # Clean up temp file if it exists
        if os.path.exists(temp_file):
            os.remove(temp_file)
        sys.exit(1)


if __name__ == "__main__":
    main()
