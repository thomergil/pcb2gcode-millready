#!/usr/bin/env python3
"""
pcb2gcode-millready

This tool modifies G-code files generated by pcb2gcode
(https://github.com/pcb2gcode/pcb2gcode) to make them more suitable for CNC
milling operations. It swaps the initial Z and X/Y moves to ensure the tool
moves to position first before plunging. This reduces the risk of damaging the
drill bit and a jig.

It can also remove M6 tool change sequences.

Note: This code was mostly generated with the assistance of AI (Claude).
"""

import re
import argparse
import os
import sys

# Constants
# (MIN_PATTERN_LINES is no longer used and has been removed)


def swap_z_and_xy_moves(infile, outfile):
    """
    Swap an initial G00 Z-safe height move and a subsequent G00 X,Y rapid
    positioning move. This ensures the tool moves to the X,Y starting position
    first, then descends to a safe Z height before any further plunging.
    Only the first occurrence is swapped.

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        bool: True if the swap was performed, False otherwise
    """
    # Read the input file
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    swapped = False  # Flag to track if we've already done the swap

    while i < len(lines):
        current_line_stripped = lines[i].strip()

        if swapped: # If already swapped, just append lines
            new_lines.append(lines[i])
            i += 1
            continue

        # Test for Z-safe move on current_line_stripped
        z_move_regex_str = r"G0[0]?\s+Z\s*[0-9.]+"
        match_z = re.match(z_move_regex_str, current_line_stripped)

        if match_z:
            # Potential Z-safe move found. Now look for the XY-rapid move, skipping empty/comment lines.
            j = i + 1
            found_xy_move_line_content = None
            found_xy_move_line_index = -1
            intervening_lines = []

            while j < len(lines):
                next_line_stripped = lines[j].strip()

                if not next_line_stripped or next_line_stripped.startswith("("):
                    intervening_lines.append(lines[j])
                    j += 1
                    continue # Skip to next line

                # Found a non-empty, non-comment line. Test if it's the XY move.
                xy_move_regex_str = r"G0[0]?\s+X.*Y"
                match_xy = re.match(xy_move_regex_str, next_line_stripped)

                if match_xy:
                    found_xy_move_line_content = lines[j]
                    found_xy_move_line_index = j
                break # Stop looking whether it matched or not, as we only consider the first non-empty/comment line

            if found_xy_move_line_content:
                # Pattern found! XY move, then intervening lines, then Z move.
                new_lines.append(found_xy_move_line_content) # XY move
                new_lines.extend(intervening_lines)          # Intervening empty/comment lines
                new_lines.append(lines[i])                   # Z-safe move

                swapped = True
                i = found_xy_move_line_index + 1 # Advance i past the processed XY line
            else:
                # Z-move was found, but no subsequent XY-move. Add current line and continue.
                new_lines.append(lines[i])
                i += 1
        else:
            # Not a Z-move, or already swapped. Add current line and continue.
            new_lines.append(lines[i])
            i += 1

    # Write the modified content to the output file
    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if swapped:
        print(
            f"Initial G00 Z<safe_height>/X,Y rapid moves swapped. Modified G-code saved to {outfile}"
        )
    else:
        print(f"No initial G00 Z<safe_height>/X,Y rapid move pattern found to swap. G-code copied to {outfile}")

    return swapped


def remove_m6_sequences(infile, outfile):
    """
    Remove M6 tool change sequences from G-code. This removes everything from
    the retract to tool change height (G00 Z...) through the lines before the
    spindle restart (M3).

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        int: Number of tool change sequences removed
    """
    # Read the input file
    with open(infile, "r") as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    sequences_removed = 0

    while i < len(lines):
        current_line_stripped = lines[i].strip()

        # Look for retract to tool change height (G00 Z followed by numbers)
        # This typically appears as "G00 Z35.00000 (Retract to tool change height)"
        retract_regex = r"G0[0]?\s+Z\s*[0-9.]+.*tool\s+change\s+height"
        match_retract = re.search(retract_regex, current_line_stripped, re.IGNORECASE)

        if match_retract:
            # Found start of tool change sequence, skip lines until we find M3 (spindle on)
            j = i + 1
            found_spindle_restart = False

            while j < len(lines):
                next_line_stripped = lines[j].strip()

                # Look for M3 (spindle on clockwise)
                if re.match(r"M3\b", next_line_stripped):
                    found_spindle_restart = True
                    break

                j += 1

            if found_spindle_restart:
                # Skip all lines from retract through the line before M3
                sequences_removed += 1
                i = j  # Continue from the M3 line
            else:
                # No M3 found, keep the current line
                new_lines.append(lines[i])
                i += 1
        else:
            # Not a tool change retract line, keep it
            new_lines.append(lines[i])
            i += 1

    # Write the modified content to the output file
    with open(outfile, "w") as f:
        f.writelines(new_lines)

    if sequences_removed > 0:
        print(f"Removed {sequences_removed} M6 tool change sequence(s). Modified G-code saved to {outfile}")
    else:
        print(f"No M6 tool change sequences found to remove. G-code copied to {outfile}")

    return sequences_removed


def main():
    """
    Main function to process command line arguments and execute G-code modifications.
    """
    parser = argparse.ArgumentParser(
        description="""
        PCB2GCode G-code Post-Processor

        Modifies G-code files generated by pcb2gcode (https://github.com/pcb2gcode/pcb2gcode)
        to make them more suitable for CNC milling operations. It can swap Z/XY moves
        for safer operation and remove M6 tool change sequences.
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument("infile", help="Input G-code file generated by pcb2gcode")
    parser.add_argument("outfile", help="Output G-code file")
    parser.add_argument("--remove-m6", action="store_true",
                       help="Remove M6 tool change sequences")
    parser.add_argument("--version", action="version", version="%(prog)s 1.0.0")

    args = parser.parse_args()

    # Check if input file exists
    if not os.path.exists(args.infile):
        print(f"Error: Input file '{args.infile}' not found.", file=sys.stderr)
        sys.exit(1)

    # Check if output directory exists
    outdir = os.path.dirname(args.outfile)
    if outdir and not os.path.exists(outdir):
        print(f"Creating output directory: {outdir}")
        os.makedirs(outdir, exist_ok=True)

    # Process the file
    try:
        if args.remove_m6:
            print("Processing: Removing M6 tool change sequences...")
            remove_m6_sequences(args.infile, args.outfile)
            # Use the output file as input for the next step
            input_for_swap = args.outfile
        else:
            input_for_swap = args.infile

        print("Processing: Swapping Z and X,Y moves...")
        swap_z_and_xy_moves(input_for_swap, args.outfile)

        print(f"Processing complete. Final G-code saved to {args.outfile}")

    except Exception as e:
        print(f"Error processing G-code: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
