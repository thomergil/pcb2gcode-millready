#!/usr/bin/env python3
"""
pcb2gcode-millready

This tool modifies G-code files generated by pcb2gcode
(https://github.com/pcb2gcode/pcb2gcode) to make them more suitable for CNC
milling operations. It swaps the initial Z and X/Y moves to ensure the tool
moves to position first before plunging. This reduces the risk of damaging the
drill bit and a jig.

Note: This code was mostly generated with the assistance of AI (Claude).
"""

import re
import argparse
import os
import sys

# Constants
# XY/Z swap pattern constants
MIN_PATTERN_LINES = 4  # Minimum lines needed for Z/XY swap pattern


def swap_z_and_xy_moves(infile, outfile):
    """
    Swap Z-down moves followed by X,Y moves to be X,Y moves followed by Z-down.

    This modification ensures the tool moves to the starting position first, then plunges down.
    Only the first occurrence is swapped, which typically is the start of the actual milling operation.
    This function also adds a move to machine Z0 (using G53) before the X,Y move to ensure tool clearance.

    Args:
        infile (str): Path to input G-code file
        outfile (str): Path to output G-code file

    Returns:
        bool: True if the swap was performed, False otherwise
    """
    # Read the input file
    with open(infile, 'r') as f:
        lines = f.readlines()

    new_lines = []
    i = 0
    swapped = False  # Flag to track if we've already done the swap

    while i < len(lines):
        # Look for Z-down move followed by X,Y move, but only swap the first occurrence
        if (not swapped and i+MIN_PATTERN_LINES-1 < len(lines) and
            re.search(r'G0[0-9]?\s+Z-', lines[i]) and  # Z-down move
            'G04 P0' in lines[i+1] and  # Dwell
            ('F' in lines[i+2] or 'F100' in lines[i+2]) and  # Feed rate
            re.search(r'G0[0-9]?\s+X.*Y', lines[i+3])):  # X,Y move

            # Keep the z-move and dwell lines but save them for later
            z_move = lines[i]
            dwell_line = lines[i+1]
            feed_line = lines[i+2]
            xy_move = lines[i+3]

            # Add the lines in the new order: Machine Z0 move first, then X,Y move, then Z down move
            new_lines.append("G53 G0 Z0\n")  # Move to machine Z0 first for clearance
            new_lines.append(xy_move)  # X,Y move
            new_lines.append(z_move)   # Z move
            new_lines.append(dwell_line)  # Dwell
            new_lines.append(feed_line)   # Feed rate

            i += MIN_PATTERN_LINES  # Skip these 4 lines since we've handled them
            swapped = True  # Mark that we've done the swap

            print(f"Added machine Z0 move (G53) and swapped first occurrence of Z and X,Y moves")
        else:
            # Keep the line as is
            new_lines.append(lines[i])
            i += 1

    # Write the modified content to the output file
    with open(outfile, 'w') as f:
        f.writelines(new_lines)

    if swapped:
        print(f"Machine Z0 move (G53) added and Z/X,Y moves swapped (first occurrence only). Modified G-code saved to {outfile}")
    else:
        print(f"No Z and X,Y move pattern found to swap. G-code copied to {outfile}")

    return swapped


def main():
    """
    Main function to process command line arguments and execute G-code modifications.
    """
    parser = argparse.ArgumentParser(
        description="""
        PCB2GCode G-code Post-Processor

        Modifies G-code files generated by pcb2gcode (https://github.com/pcb2gcode/pcb2gcode)
        to make them more suitable for CNC milling operations. It swaps Z/XY moves
        for safer operation.
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('infile', help='Input G-code file generated by pcb2gcode')
    parser.add_argument('outfile', help='Output G-code file')
    parser.add_argument('--version', action='version', version='%(prog)s 1.0.0')

    args = parser.parse_args()

    # Check if input file exists
    if not os.path.exists(args.infile):
        print(f"Error: Input file '{args.infile}' not found.", file=sys.stderr)
        sys.exit(1)

    # Check if output directory exists
    outdir = os.path.dirname(args.outfile)
    if outdir and not os.path.exists(outdir):
        print(f"Creating output directory: {outdir}")
        os.makedirs(outdir, exist_ok=True)

    # Process the file
    try:
        print("Processing: Swapping Z and X,Y moves...")
        swap_z_and_xy_moves(args.infile, args.outfile)

        print(f"Processing complete. Final G-code saved to {args.outfile}")

    except Exception as e:
        print(f"Error processing G-code: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
